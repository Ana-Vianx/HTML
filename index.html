<!DOCTYPE html>
<html lang="pt-br"> <!--define o idioma-->
    <head>
        <meta charset="UTF-8"> <!--define quais caracteres estamos usando para suportar a acentuação-->
        <meta http-equiv="X-UA-Compatible" content="IE-edge"><!--puxa a configuração mais recente do navegador do egde-->
        <meta name="viewport" content="wildth=device-width, initial-scale=1.0">
        <title>Não há Bala de Prata para o Desenvolvimento de Software</title>
        <link rel="stylesheet" href="style.css"
    </head>
    <body>
        <header></header>
        <main class: "artigo">
            <div class="parte1">
                <h1>Não há <strong>Bala de Prata</strong> para o Desenvolvimento de Software</h1>
                <h3>“Não há um único desenvolvimento, seja em tecnologia ou técnica de gestão, que por si só prometa uma melhoria de uma ordem de magnitude em uma década em produtividade, confiabilidade e simplicidade” — Frederick P. Brooks, Jr.</h3>
                <p>Uma tradução livre para essa frase poderia ser: “Não há nenhuma metodologia individual de desenvolvimento, em tecnologia ou técnicas de gestão, que por si só promete um incremento ainda que de uma ordem de grandeza dentro de uma década em produtividade, em confiabilidade, em simplicidade”. Ou seja, não há uma bala de prata que sozinha resolva os problemas do Software.<br><br>
                Neste artigo, o autor faz uma brilhante — e também estranha — analogia entre o Software e o Lobisomem, alegando que estes seres se transformam, inesperadamente, de coisas familiares em seres horripilantes. A diferença é que para o Lobisomem, basta uma bala de prata para se resolver o problema. Em relação ao Software , os horrores seriam os prazos perdidos, orçamentos estourados e produtos com falhas, só que diferentemente do Lobisomem, não há uma única bala de prata que resolva esses problemas.</p>
            </div>
            <div class="parte2">
                <div class="imagem">
                    <img src="image.webp" alt="Autor do artigo 'No Silver Bullet'">  
                </div>
                <div class="texto">
                    <p>Abaixo um breve resumo dos aspectos tratados pelo autor que, em sua argumentação, divide os problemas envolvidos ao desenvolvimento de Software em dois: acidentais e essenciais. Os problemas acidentais dizem respeito aos problemas relacionados à fabricação do Software e estão quase sempre associados a limitações tecnológicas. Já os problemas essenciais são aqueles inerentes à sua própria natureza, e como veremos, são uma causa real de sua complexidade.<br><br>
                    Se analisarmos bem, muitos dos problemas acidentais têm sido resolvidos ao longo dos anos. As restrições de memória e processamento de hoje nem se comparam com as de 30 anos atrás, sem contar que hoje desenvolvemos num ambiente multitarefa — imagine só você programando sua aplicação para um sistema de processamento em lote. Outra coisa que contribuiu bastante para a eliminação dos problemas acidentais são as linguagens de alto nível, que evoluíram têm feito bastante e cada vez mais positivas para a produtividade do desenvolvimento, confiabilidade e simplicidade do Software . Sabemos que essas linguagens não possuem o mesmo desempenho de linguagens de mais baixo nível, como por exemplo C; entretanto, conforme a aceleração evoluem, vale a pena se trocar alguns ciclos por essas melhorias.<br><br>
                    Mas porque o desenvolvimento continua tão complexo mesmo com tantas melhorias?<br>
                    <strong> Resposta: Porque os seus principais desafios não são os acidentais, mas sim os essenciais.</strong><br><br>
                    Como já foi dito, os problemas essenciais dizem respeito às características que são inerentes somente ao Software . Eles se referem aos desafios da criação de um modelo conceitual para os sistemas. Neste sentido, Brooks elenca quatro desafios referentes a softwares que dificilmente são encontrados em outras ciências.</p> 
                </div>
            </div>
            <div class="parte3">
                <ul>
                    <li><p>Complexidade : a qual se refere ao fato de que no desenvolvimento Software não existem dois elementos repetidos ou idênticos, quando existem eles são transformados em uma coisa só na forma de funções. Essa característica é um grande desafio na hora de escalar o Software para desafios maiores, uma vez que não basta o uso dos mesmos componentes em tamanho maior, como muitas vezes acontece com o Hardware, construções, automóveis e outras máquinas, onde os elementos se repetem superabundam. Dessa forma, não há crescimento linear para o Software.</p></li>
                    <li><p>Conformidade : Não é só o Software que sofre com os problemas de complexidade, a física por exemplo também sofre, no entanto, diferentemente desta última o Software não possui leis imutáveis ​​como quais podem se agarrar. O Software precisa se adaptar a todo tipo de interface, sistema ou instituição existente, e se não bastasse, estes supostos padrões mudam de tempos em tempos de acordo com a moda do momento. Como diz o autor, as vezes não é nem por necessidade, mas simplesmente porque os padrões são desenvolvidos por pessoas e não por Deus, como no caso da física e das leis da natureza.</p></li>
                    <li><p>Alterabilidade : O Software está constantemente sujeito a pressão por mudança. Isso deve ter sua característica abstrata que lhe confere a impressão de que mudanças são fáceis de se fazer, muito diferentes do que ocorre com os produtos fabricados no mundo físico. Para tal, basta comparar a quantidade de recalls que acontecem no setor automobilístico com a quantidade de atualizações na indústria de Software . Esta característica é em parte benéfica para permitir uma evolução 'rápida' dos sistemas, entretanto, paga-se o preço para tal.</p></li>
                    <li><p>Invisibilidade : Essa é talvez a característica mais intuitiva, acredito que todos já ouviram aquela famosa expressão de que o Software é aquilo que se xinga. Pois é, o Software é de fato invisível, não é possível representá-lo a partir de formas geométricas ou outras formas descobertas pelo senso comum. Esta característica representa um grande desafio para o projeto de sistemas e sua representação para terceiros.</p></li>
                </ul>
                <p>Considerando essas características de forte cunho abstrato, não é difícil de se concluir que simplesmente existirá uma única solução que alavanque a produtividade, a confiabilidade e a simplicidade do Software , assim como por exemplo foram os transistores para a eletrônica.<br>
                Entretanto, dada esta extensa discussão, onde a segurança se encaixa? É preciso entender que a segurança é também um atributo do Software , assim como usabilidade, desempenho, simplicidade, entre outros. Portanto, os desafios acima mencionados impactam a segurança de igual forma, uma vez que é igualmente difícil de se implementar a segurança a algo que precisa se adaptar a tudo, que vive sendo alterado e é de difícil representação.<br>
                Diante de tudo isso, o primeiro ponto é que os problemas de segurança no software decorrem primeiramente de sua própria complexidade. É importante compreendermos isso antes de atirarmos nossas pedras em quem quer que seja. A evolução da segurança no Software continuará a ser gradual e fruto de um conjunto de atividades e processos. Se você ainda espera uma solução mágica para esse problema, esqueça, pois isso não vai acontecer.</p>
                <!-- a é a âncora que leva a outro site-->
                <div class="botoes">
                    <a class="botao" href="https://worrydream.com/refs/Brooks_1986_-_No_Silver_Bullet.pdf">Artigo original</a>
                    <a class="botao"href="https://medium.com/securityin/n%C3%A3o-h%C3%A1-bala-de-prata-para-o-desenvolvimento-de-software-2d7e033e343a">Artigo traduzido</a>
                </div>
                
            </div>
        </main>
    </body>
</html>
